#CELL NUMBER / PROTEIN DISTRIBUTIONS
#___________________________________

#vector in formate [[<range start>,<range end>], <number of different proteins in this range>] seperated by ;
#for the inirange we can only change ONE START and ONE END VALUE for ONE range indicated with an X (e.g. one RANGE START: [[1,2],3];[[X,Y],2])
#the values for X and Y are geiven, seperated by a ';'

#example varying number of high proteins
ProteinLevels=[[[750,800],0];[[200,300],30];[[10000,15000],X]]
ProteinLevelsINIRANGE=0,2,1

#example for a varying range
#ProteinLevels=[[[750,800],2];[[200,1000],10];[[X,Y],1]]
#ProteinLevelsINIRANGE=900,30000,15000;901,30001,15000

#size parameter for the negBinom distributions of the proteins
size=3.5
CellNumber=500

#random (gaussian dist) noise that is applied randomly to every protein count in every single cell (len(single cell*protein) different factor)
#noise is the width of a normal dist, that samples a factor to multiply the ab_count
noise=0.05
#noiseINIRANGE=0.01,1,0.01
#proteinNoise (len(protein) different factors): noise like above, but this is a protein specific noise. E.g., protein X has more noise than protein Y, therefore firstly 
#protein counts are multiplied with the same factor for same protein here, afterwards to above noise is applied for every individual
#count
proteinNoise=0.1
#proteinNoiseINIRange=0.1,0.9,0.05

#AB DUPLICATE SIMULATION (POTENTIAL NORMALIZATION)
#___________________________________
#if dubplicated ABs should be used -> increases total number of ABs
abDuplicates=1
#factor for differences between ABs within this range
abDuplicateRange=[1,1]
#we disturb the duplicate AB counts in the following way
#1.) multiply with a random value between abDuplicateRange 2.) put gaussian noise around this value, 
#sigma of this gaussDist is the abDuplicateDisturbance * <above calculated new ABcount>abDuplicateDisturbance=0.1
#parameter for Sampling of AntiBodyBinding: sample <number sampled ABs per smaple> elements from the data  (<number sampled ABs per smaple> = <protein count per sample> * <abBindingEfficiency>)
abBindingEfficiency=0.9

#SEQUENCING DEPTH SIMULATION
#___________________________________
#library size, first value mean, second std (new implementation: removed range of libsize values)
libSize=[1,0.1]
#parameter for the iniFile construction, for each iniFile a new libSize line is generated in the format libSize=[1,range(X,Y,Z)] (pythonrange: from X toY with steps Z)
#format:<libSizeRange=X,Y,Z>
#libSizeINIRANGE=1,4

#THIS IS CURRENTLY COMMENTED OUT, BUT CAN BE ENABLED AGAIN
#IT SHOULD THEN BE USED INSTEAD OF LIBSIZE (fixed factors of libsize effect)
#THIS SIMULATES PCR CYCLES, CAPTURE, AMPLIFICATION TO INTRODUCE LIBSIZE EFFECTS (which is not totally true bcs pcr could be hadnled
#by UMIs...)
#PCR PARAMETERS
pcrCycles=2
pcrCapture=0.8
#parameter for Sampling of PCRAmplification+Sequencing: sample <number sampled UMIs> elements from the data ( <number sampled UMIs> = <unique UMIs> * <seqAmplificationEfficiency>)
seqAmplificationEfficiency=0.6


#TREATMENT EFFECT AS DISCRETE CLUSTERS
#___________________________________
#treatments, additionally to base-condition => number of conditions = num of vectors inside treatmentVector +1
#each vector itself can be a vector of p[roteins that r effected within this treatment
#vector of treatment vectors (';' seperated) enclosed in '[]', each value is the alteration of one random protein count within this one treatment
#it is the factor that rescales the proteinCounts for a condition ABcount *= treatmentValue
#value range: 0.0 - <1.0 for a negative effect; >1 for a positive one
# 2 additonal clusters next to baseline, one for each semicoon seperated parameters (they r evenly split among cells for now)
diffExProteinsFactors=[20.2,34.5];[0.01]
#corresponding proteins to treatmentVector
diffExProteins=[1,2];[3]

#BATCH EFFECT
#___________________________________
#list of factors for the batches, the factor states how much the proteinCounts deviate from thre ground truth
#every sample (cell) is randomly assigned to one of the batches with len(batches)==len(batchFactors)
batchFactors=1,0.7

#CORRELATIONS
#___________________________________
#INIRANGE is more difficult for this one: it looks as follows:
#proteinCorrelationINIRANGE=startNumberRange,endnumberrange,steps;startFactor,EndFactor,steps
#for more details look in ScNormalisation.md file
#Parameters to model simple signal transduction networks (needed e.g. for graph normalization)
#proteins are generated starting with idex 1, they r generated in the order as mentioned in ProteinLevels in the top
#for the correlated pairs gaussian multivariate values are calculated and then ranked
#afterwards neg.binom counts are generated and ordered after the ranks of the gaussian dist
#the factors are spearman correlations, the fact for beeing a pos or neg correlations is determined by the sign
#in proteinCorrelation
proteinCorrelation=[[1+2],[3+4],[5-6]]
proteinCorrelationFactors=[0.3,0.5,0.3]

#PARAMETERS ONLY USED FOR BENCHMARKING OF SIMULATIONS (TMM,CLR_COMPOSITIONS,SUBSAMPLING,GRAPH,LIBSIZE)
#___________________________________
normMethods=TMM,LIBSIZE,SANITY
batchEffect=0
